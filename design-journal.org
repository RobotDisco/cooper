#+TITLE: Cooper Memorial Project, design journal
#+AUTHOR: Gaelan D'costa
#+EMAIL: gdcosta@gmail.com
#+LANGUAGE: en
#+STARTUP: indent align hidestars oddeven
#+PROPERTY: tangle cooper game designjournal

* Introduction
** I had a cat.
   I moved to Toronto in 2011. It wasn't something I decided on myself; my 
   partner at the time was intending on going to University here.

   Very soon after moving here, possibly in the first or second month, certainly
   not long enough for me to have been working for more than a paycheque or two,
   my partner at the time decided to "adopt" a stray cat that had apparently
   lived in our neighbourhood for a while. He had been living off discarded food
   from a nearby taxicab parking area and slept in a small shelter a neighbour
   had set up (he had cats of his own and could not safely bring this cat in.)

   At this time I was the only one of our household who was employed, and this
   went against my fiscally paranoid sensibilities. But I couldn't argue against
   rescuing an outdoor cat who showed no hostility to me, so we scooped him up
   and made him ours. We named him *Special Agent Dale Cooperr* after our
   favourite TV Show at the time.

   In time my partner and I were no longer together, but it made more sense for
   me to keep Cooper. Not that I minded; I had learned how to care for him and I
   very much needed his companionship. He was the first opportunity for me to
   provide for someone with full awarenesss and understanding, which was very
   important to me as someone who was not taught how to do so as a child and was
   conditioned, both as aa software developer and as a North American male, to
   have considered myself intrinsically incapable of doing so until I was forced
   to do so on my own.

   We shared much time together, mostly in health but for a few years at the end
   in a sicknesss from which he finally succumbed to by March 2020. In a final
   gift to me, he in some ways strengthened me for the upcoming pandemic and
   environmental and social strife we would face in this year of pandemic and
   reckoning of a deel social history of racial inequity: it was easy to move
   through displacement of lockdown and employment fears after two years of
   diagnosing, treating, and finally burying my feline child.

   I had a particular cat from 2011 until 2020; and while I am at peace with his
   ended time, I am still adjusting to it, and trying to find some way in which
   to manifest it. I am hopinng to do so while developing a small game project
   with him in mind.
** I played a game
   One of the earliest things I remember doing as a child after moving to Canada
   was gathering around my cousin's computer, popping in one of the random
   scattered shareware compendiums some parent in our extended family had gotten
   for us, and playing one of the many games that piqued my interest.

   One game I clocked a lot of time in was called [[https://en.wikipedia.org/wiki/Toppler][Perestroika]]. It was a very
   strange game. It opened with a picture of a recently-collapsed Soviet
   iconography I barely comprehended from CNN footage. The language was all
   using characters that made no sense to my latin-exclusive education.

   But the game was ultimately a simple platformer, and the few sprites included
   were very cute. Much later I would learn that there was s deliberate
   political statement driving the game, and the idea of a polemic arcade game
   would endear it to mme further as an adult.
** Synthesis and mission
   I want to write something that commemorates some expression of loss for my
   first cat. Why not try to theme an implementation of a childhood game I very
   much enjoyed?
* The Source Material
** What are Perestroika's rules?
From wikipedia:
#+BEGIN_QUOTE
The game consists of controlling a small frog-like creature which jumps from one
lily pad to another, trying to collect dots in four colours symbolizing grocery
goods, currency transactions, progressive taxes and adventures and to reach a
certain pad in the right-top corner of the screen. The lilies, symbolizing the
ever-changing laws and acts in the USSR, constantly shrink and disappear only to
appear in other places. Higher levels also feature one or more evil creatures
called "bureaucrats" which follow the frog and try to eat it. The frog dies if
the lily pad on which it is standing disappears, if the player moves it to a
place where there is no lily pad, or if it is caught by a bureaucrat.
#+END_QUOTE
** Intended cooperification
+ The protagonist will represent Cooper
+ Unsure as yet what the petals will become.
+ The coin at the end will become Fried Chicken, the food he most tried to steal
+ The "bureaucraats" will either represent me or my other cat as obstacles
+ I am yet unsure what the other point items will represent.
** Reference Implementation
I found a [[http://michal.biniek.pl/games/toppler.html][Javascript implementation]] I can look at for guidance.
* Earlier Attempts
** Lisp Game Jam
Originally I was going to do this for a Lisp game jam. The week of the jam, my
work downsized because of COVID. I was not impacted but I spent much of the week
trying to deal with the fallout and make sure the people who were were ok. By
the time I got around to noticing the Lisp game jam had started, I had only two
days left.

I originally rushed an attempt by beginning from the user interface. I spent the
weekend learning how to render a 2D environment via the [[https://github.com/oakes/play-cljc][play-cljc]] project.

It was gratifying to see shapes render on the screen in a weekend, but over the
next few weeks I wrote myself into a corner as I could not untangle my game
logic from the rendering code. In addition, I was trying to learn WebGL concepts
while also trying to piece together game logic at the same time.

At some point I had to give up because I simply could not figure out how to work
on one component without impacting or breaking other components, and the flow of
the program was incredibly difficult to navigate. 

In addition, the =play-cljc= author's template assumed an incredibly different
workflow from mine, which meant I was constantly stopping and starting the
program and I could not debug it from inside the editor. I was gaining none of
the advantages of using clojure.

The last commit of this particular attempt can be found [[https://github.com/RobotDisco/cooper/tree/7b79cba8edb6051abf8934549f0f79c5b7c514b0][here]]
** Rip it up and Start Again
I then recreated the projet from scratch after doing some small courses on data
modelling and using the Clojure REPL. This has proven to be a much nicer
environmment. I am indebted to [[https://purelyfunctional.tv][Eric Normand]] for producing some very useful
courses on these subjects.

I am trying to do most of my prototyping in the REPL, convering experiments into
tests. I was able to generate petal logic and a small amount of player logic
doing so, with test-driven development keeping my understanding of the logic
matching what the code actually implemented.

After I was comfortable with my design and tests, I would use =clojure.spec= to
add type-checking to the data and functions. I was aware this was puting the
cart before the horse but I was still learning about this technique and a lot of
the promised paradigm shifting took a bunch of time for me to absorb. I am now
starting to realize it would be nice if I had designed my functions and data
such that my tests and data could be tested by property-based testing instead of
via me constructing specific examples, although that method is still very
strange to me.

I also started learning enough about =deps.edn= to produce a nice workflow for
myself, using aliases and plugins to allow for linting and idiom-checking, for
automated testing, and for dependency management. I am indebted to the
[[https://practicalli.github.io/clojure/][practicalli clojure guide]] and their curated [[https://github.com/practicalli/clojure-deps-edn][deps.edn alias set]] for finally
showing me how to produce a good starting place for developing clojure
applications.

This was when I learned about the idea of a design journal, where one keeps
around one's REPL explorations as a way of recording how one developed the shape
of their program instead of removing them when done. I wish I had preserved my
earlier explorations for petal and player logic but I will have to recreate
them.
* Petal models
** 2020-06-26
Starting with the petals. They're somewhat bimodal, they have two states
effectively
+ hidden with a countdown to respawning
+ visible with a randomly selected rate

The petals so far have just one function, a advance. Here are its rules
+ if visible, shrink the petal by its shrinking rate
+ if visible but size <= 0, flip to visible and start randomly picked countdown
  length
+ if invisible, tick the countdown by one
+ if invisible but countdown = 0, flip to visible with a randomly selected
  shrinking rate

I should probably play around with some ideas now. Here are mock visible petal
which may or may not be complete.
#+BEGIN_SRC clojure :results silent
  ;; A petal can be visible, with a size that shrinks according to a rate
  (def visible-petal-mock {:size 100 :rate 10})
  ;; or a petal can be invisible, with a countdown until it becomes visible again
  (def invisible-petal-mock {:countdown 100})
#+END_SRC

Let's write a stub version of the advance-petal function.
#+BEGIN_SRC clojure :results silent
  (defn advance-petal
    "Progress the petal forward in time.

    If visible, shrink the petal by its shrinking rate. If invisible, tick the
    countdown timer by one.  If the relevan visible/hidden petals values reach a
    zero value or lower (size/countdown respectively) then flip them into the
    alternating state with randomized new starting conditions.

    Arguments:
    - petal to advance
    Return:
    - petal having moved forward in time, including flipping state."
    [petal]
    petal)
#+END_SRC

Let's write some characterization tests using our mocks.
#+BEGIN_SRC clojure :results silent
  (require '[clojure.test :refer [deftest is testing]])

  (def visible-petal-full {:size 100 :rate 10})
  (def visible-petal-empty {:size 0 :rate 10})

  (deftest visible-petal-test
    (testing "Full petal shrinks"
      (let [shrunk-petal (advance-petal visible-petal-full)]
        (is (< (:size shrunk-petal) (:size visible-petal-full)))
        (is (= (+ (:size shrunk-petal) (:rate shrunk-petal))
               (:size visible-petal-full))))))

  (visible-petal-test)
#+END_SRC

OK Let's try implementing that test in the function.
#+BEGIN_SRC clojure :results silent
  (defn advance-petal
    "Progress the petal forward in time.

    If visible, shrink the petal by its shrinking rate. If invisible, tick the
    countdown timer by one.  If the relevan visible/hidden petals values reach a
    zero value or lower (size/countdown respectively) then flip them into the
    alternating state with randomized new starting conditions.

    Arguments:
    - petal to advance
    Return:
    - petal having moved forward in time, including flipping state."
    [{:keys [size rate] :as petal}]
    (assoc petal :size (- size rate)))
#+END_SRC
** 2020-06-27
*** Unit testing petals
OK sweet let's implement all our tests now
#+BEGIN_SRC clojure :results silent
  (require '[clojure.test :refer [deftest is testing]])

  (def visible-petal-full {:size 100 :rate 10})
  (def visible-petal-empty {:size 0 :rate 10})

  (def invisible-petal-mock {:countdown 100})

    (deftest visible-petal-test
      (testing "Full petal shrinks"
        (let [shrunk-petal (advance-petal visible-petal-full)]
          (is (< (:size shrunk-petal) (:size visible-petal-full)))
          (is (= (+ (:size shrunk-petal) (:rate shrunk-petal))
                 (:size visible-petal-full)))))
      (testing "Empty petal flips"
        (let [flipped-petal (advance-petal visible-petal-empty)]
          (is (= (set (keys flipped-petal))
                 (set (keys invisible-petal-mock)))))))
#+END_SRC
OK new function definition
#+BEGIN_SRC clojure :results silent
  (defn advance-petal
    "Progress the petal forward in time.

    If visible, shrink the petal by its shrinking rate. If invisible,
    tick the countdown timer by one.  If the relevan visible/hidden
    petals values reach a zero value or lower (size/countdown
    respectively) then flip them into the alternating state with
    randomized new starting conditions.

    Arguments:
    - petal to advance
    Return:
    - petal having moved forward in time, including flipping state."
    [{:keys [size rate] :as petal}]
    (if (zero? size)
      {:countdown 100}
      (assoc petal :size (- size rate))))
#+END_SRC
OK sweet let's just implement the rest of the function
#+BEGIN_SRC clojure :results silent
  (require '[clojure.test :refer [deftest is testing]])

  (def visible-petal-full {:type :visible :size 100 :rate 10})
  (def visible-petal-empty {:type :visible :size 0 :rate 10})

  (def invisible-petal-pending {:type :hidden :countdown 100})
  (def invisible-petal-triggers {:type :hidden :countdown 0})

  ;; I have split this into a multi-method because the way that `visible` and
  ;; `hidden` petals work are very different, but I want to use them in the
  ;; same places, and I don't want to break Liskov. Also this allows me to
  ;; have two completely separate structures without needing to have two
  ;; layers of branching in the `advance` function.
  (defmulti advance-petal
      "Progress the petal forward in time.

      If visible, shrink the petal by its shrinking rate. If invisible,
    tick the countdown timer by one.  If the relevan visible/hidden
    petals values reach a zero value or lower (size/countdown
    respectively) then flip them into the alternating state with
    randomized new starting conditions.

      Arguments:
      - petal to advance
      Return:
      - petal having moved forward in time, including flipping state."
    :type)

  (defmethod advance-petal :hidden
    [{:keys [countdown] :as petal}]
    (if (zero? countdown)
      {:type :visible :size 100 :rate 10}
      (assoc petal :countdown (dec countdown))))

  (defmethod advance-petal :visible
    [{:keys [size rate] :as petal}]
    (if (zero? size)
      {:type :hidden :countdown 100}
      (assoc petal :size (- size rate))))

  (deftest visible-petal-test
    (testing "Full petal shrinks"
      (let [shrunk-petal (advance-petal visible-petal-full)]
        (is (< (:size shrunk-petal) (:size visible-petal-full)))
        (is (= (+ (:size shrunk-petal) (:rate shrunk-petal))
               (:size visible-petal-full)))))
    (testing "Empty petal flips"
      (let [flipped-petal (advance-petal visible-petal-empty)]
        (is (= (set (keys flipped-petal))
               (set (keys invisible-petal-pending)))))))

  (deftest invisible-petal-test
    (testing "Pending respawn counts down"
      (let [pending-respawn (advance-petal invisible-petal-pending)]
        (is (= (inc (:countdown pending-respawn))
               (:countdown invisible-petal-pending)))))
    (testing "Hidden petal respawns when countdown finished"
      (let [flipped-petal (advance-petal invisible-petal-triggers)]
        (is (= (set (keys flipped-petal))
               (set (keys visible-petal-full)))))))
#+END_SRC
Excellent so that worked. I think it's time to get this specc'd
*** A momentary question and deferral of random petal generation.
It seemed super important to me that I write some functionality for random
generation of rates and countdown values. It made things weird, always, but
right now my petals with their fixed respawn and shrink rates seems pretty
contrived. Shouldn't this be considered essential MVP complexity?

I am starting to think it shouldn't be. While I can make the respawn randomness
parameterizable, from a /feedback/ point of view it also makes it harder for me
to understand what is going on as I try to reason about the currently
implemented "world" of my game. I think I'm going to have to added it in as one
of the earliest -- if not *the* earliest -- release milestones, but I can
implement it later and right now that randomness only complicates my code and
makes it harder for me to test future things. Let's leave the game running as
statically as possible as I implement the player, game map, point system, and so
on. We'll add randomness in when I have more comfort in the overall stability of
the system.
*** Let's spec this sucker
A major part of switching to Clojure is that I can use spec to produce runtime
-- and optional! -- static checking and property-based assertion of my code at
the fuction/data definition layer.  Now that I have my unit tests, which are in
fact characterization tests, let's add some typing to the model and also see if
I can produce generative/property-based tests that leverage this!







